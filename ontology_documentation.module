<?php

// Definisco il tipo di entità da gestire
define('__documentation_type__', 'ontology_documentation');
// Definisco il tipo di bundle da gestire
define('__documentation_type_bundle__', __documentation_type__.'_type');
// Definisco il path per le pagine di documentazione
define('__documentation_view_path__', str_replace('_', '-', __documentation_type__));
// Definisco l'url per la pagina di gestione delle entità
define('__documentation_admin_path__', 'admin/'.__documentation_view_path__);
// Definisco il path per la pagina di gestione bundle
define('__documentation_bundle_admin_path__', 'admin/structure/'.str_replace('_', '-', __documentation_type_bundle__));
// Definisco l'url per le pagina di ragionamento
define('__reasoning_relative_path__', 'intensional-reasoning');
// Definisco l'url per le pagina dei mappings
define('__mappings_relative_path__', 'mappings/ontology');
// Definisco il nome della classe di frontend
define('__documentation_type_util__', __documentation_type__.'.util.inc');
// Definisco il percorso del modulo
define('__module_path__', drupal_get_path('module', __documentation_type__));

// Includo la classe di utility
require_once DRUPAL_ROOT.'/'.__module_path__.'/'.__documentation_type_util__;

/**
 * Implements hook_help().
 */
function ontology_documentation_help($path, $arg) {
  switch ($path) {
    case "admin/help#ontology_documentation":
      $help_form['header'] = array(
      '#type' => 'html_tag',
      '#tag' => 'h3',
      '#value' => 'Ontology documentation'
    );
    $help_form['content'] = array(
      '#type' => 'html_tag',
      '#tag' => 'em',
      '#value' => 'Upgrade OWL documentation pages',
    );
    break;
  }
  return drupal_render($help_form);
}

/**
 * Implements hook_entity_info().
 */
function ontology_documentation_entity_info() {
  $entity_info = array();

  $entity_info[__documentation_type__] = array(
    'label' => 'Ontology documentation',
    'plural label' => 'Ontology Entities',
    'entity class' => 'OntologyDocumentation',
    'controller class' => 'OntologyDocumentationController',
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => __documentation_type__,
    'revision table' => __documentation_type__.'_revision',
    'fieldable' => TRUE,
     'entity keys' => array(
      'id' => 'odid',
      'revision' => 'rodid',
      'bundle' => 'category',
      'label' => 'title',
    ),
    'bundle keys' => array(
      'bundle' => 'category',
    ),
    'bundles' => array(),
    'view modes' => array(
      'full' => array(
      'label' => t('Full Content'),
      'custom settings' => FALSE,
      ),
    ),
    'module' => 'ontology_documentation',
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'access callback' => 'ontology_documentation_access',
    'admin ui' => array(
      'path' => __documentation_admin_path__,
      'file' => 'ontology_documentation.admin.inc',
      'controller class' => 'OntologyDocumentationUIController',
    ),
  );
  $entity_info[__documentation_type_bundle__] = array(
    'label' => 'Ontology documentation type',
    'plural label' => 'Ontology Entities types',
    'entity class' => 'OntologyDocumentationType',
    'controller class' => 'OntologyDocumentationTypeController',
    'base table' => __documentation_type_bundle__,
    'fieldable' => FALSE,
    'bundle of' => __documentation_type__,
    'entity keys' => array(
      'id' => 'category',
      'label' => 'title',
      'status' => 'locked',
    ),
    'module' => 'ontology_documentation',
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'access callback' => 'ontology_documentation_access',
    'admin ui' => array(
      'path' => __documentation_bundle_admin_path__,
      'file' => 'ontology_documentation.admin.inc',
      'controller class' => 'OntologyDocumentationTypeUIController',
    ),
  );

 return $entity_info;
}

/**
 * Implements hook_entity_info_alter().
 */
function ontology_documentation_entity_info_alter(&$entity_info) {
  foreach (ontology_documentation_util('get_bundles', 'ALL') as $bundle) {
    $entity_info[__documentation_type__]['bundles'][$bundle['machine_name']] = array(
      'label' => $bundle['human_label'],
      'uri callback' => 'entity_class_uri',
      'admin' => array(
        'path' => __documentation_bundle_admin_path__.'/manage/%'.__documentation_type_bundle__,
        'bundle argument' => 4,
        'real path' => __documentation_bundle_admin_path__.'/manage/'.$bundle['machine_name'],
        ),
    );
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ontology_documentation_form_ontology_documentation_overview_form_alter(&$form, &$form_state, $form_id) {
  // Aggiungo il css alla tabella
  $form['table']['#attached']['css'] = array(__module_path__ .'/css/entity_table_form.css');
}

/**
 * Implements hook_entity_property_info().
 */
function ontology_documentation_entity_property_info() {
  $entity_property_info = array();

  // Metto a conoscenza il wrapper delle proprietà possedute da __docouemntation_type__
  $entity_property_info[__documentation_type__]['properties'] = array(
    'id' => array(
      'label' => t(__documentation_type__.' id'),
      'description' => t('The id of the ontology term'),
      'type' => 'integer',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'odid',
     ),
    'rid' => array(
      'label' => t(__documentation_type__.' revision id'),
      'description' => t('The revision id of the ontology term'),
      'type' => 'integer',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'rodid',
    ),
    'name' => array(
      'label' => t(__documentation_type__.' title'),
      'description' => t('The title of the ontology term'),
      'type' => 'text',
      'schema field' => 'title',
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'type' => array(
      'label' => t(__documentation_type__.' categoty'),
      'description' => t('The category of the ontology term'),
      'type' => 'text',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'category',
    ),
    'lang' => array(
      'label' => t(__documentation_type__.' language'),
      'description' => t('The language of the ontology term'),
      'type' => 'text',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'language',
    ),
    'uid' => array(
      'label' => t(__documentation_type__.' uid'),
      'description' => t('The user id creator of the ontology term'),
      'type' => 'integer',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'uid',
    ),
    'creation_date' => array(
      'label' => t(__documentation_type__.' created date'),
      'description' => t('The timestamp creation of the ontology term'),
      'type' => 'date',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'created',
    ),
    'modification_date' => array(
      'label' => t(__documentation_type__.' cached date'),
      'description' => t('The timestamp modification of the ontology term'),
      'type' => 'date',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'changed',
    ),
    'state' => array(
      'label' => t(__documentation_type__.' status'),
      'description' => t('The status of the ontology term'),
      'type' => 'integer',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'status',
    ),
  );
  // Metto a conoscenza il wrapper delle proprietà possedute da __documentation_type_type__
  $entity_property_info[__documentation_type_bundle__]['properties'] = array(
    'type' => array(
      'label' => t(__documentation_type_bundle__.' category'),
      'description' => t('The category of the bundle'),
      'type' => 'text',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'category',
     ),
    'name' => array(
      'label' => t(__documentation_type_bundle__.' title'),
      'description' => t('The title of the bundle'),
      'type' => 'text',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'title',
    ),
    'description' => array(
      'label' => t(__documentation_type_bundle__.' description'),
      'description' => t('The description of the bundle'),
      'type' => 'text',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'description',
    ),
  );
  return $entity_property_info;
}

/**
 * Implements hook_admin_paths().
 */
function ontology_documentation_admin_paths() {
  $paths = array(
    __documentation_view_path__.'/*/*/edit' => TRUE,
   __documentation_view_path__.'/*/*/edit/add-revision' => TRUE,
  );
  return $paths;
}

/**
 * Implements hook_menu().
 */
function ontology_documentation_menu() {
  $items = array();

  $items['admin/config/mastro/'.__documentation_view_path__] = array(
    'title' => 'Ontology Documentation',
    'description' => 'Upgrade OWL documentation pages',
    'access callback' => 'entity_access',
    'access arguments' => array('update', __documentation_type__, NULL, NULL),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ontology_documentation_config_form'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'ontology_documentation.callback.inc',
  );
  $items[__documentation_view_path__.'/%/%ontology_documentation'] = array(
    'title' => 'Root',
    'load arguments' => array(__documentation_type__, 1),
    'access callback' => 'entity_access',
    'access arguments' => array('view', __documentation_type__, 2, NULL),
    'page callback' => 'ontology_documentation_term_view',
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
    'file' => 'ontology_documentation.callback.inc',
  );
  $items[__documentation_view_path__.'/%/%ontology_documentation/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'ontology_documentation.callback.inc',
    'weight' => -1,
  );
  $items[__documentation_view_path__.'/%/%ontology_documentation/edit'] = array(
    'title' => 'Edit',
    'load arguments' => array(__documentation_type__, 1),
    'access callback' => 'entity_access',
    'access arguments' => array('update', __documentation_type__, 2, NULL),
    'page callback' => 'entity_ui_get_form',
    'page arguments' => array('ontology_documentation', 2, 'edit'),
    'file' => 'ontology_documentation.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items[__documentation_view_path__.'/%/%ontology_documentation/edit/add-revision'] = array(
    'title' => 'Create new revision',
    'load arguments' => array(__documentation_type__, 1),
    'access callback' => 'entity_access',
    'access arguments'=> array('create', __documentation_type__, 2, NULL),
    'page callback' => 'entity_ui_get_form',
    'page arguments' => array('ontology_documentation', 2, 'create'),
    'file' => 'ontology_documentation.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );

 /**
  *
  * Togliere il commento se si vuole implementare la possibilità
  * di aggiungere nuova documentazione per un nuovo termine creato a mano.
  * Le funzioni di callback sono definite nel file ontology_documentation.callback.inc.
  * Ricordarsi di scommentare anche le parti nel file *.install
  *
  **/
  /*
  $items['admin/'.__documentation_base_url__.'/add'] = array(
    'title' => 'Add Ontology documentation',
    'page callback' => 'system_admin_menu_block_page',
    'access callback' => 'entity_access',
    'access arguments' => array('create', __documentation_type__, NULL, NULL),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/'.__documentation_base_url__.'/add/concept'] = array(
    'title' => 'Add Concept',
    'description' => 'Allow you to create a new OWL concept',
    'page callback' => 'ontology_documentation_concept_create',
    'access callback' => 'entity_access',
    'access arguments' => array('create', __documentation_type__, NULL, NULL),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'ontology_documentation.callback.inc',
  );
  $items['admin/'.__documentation_base_url__.'/add/role'] = array(
    'title' => 'Add Role',
    'description' => 'Allow you to create a new OWL role',
    'page callback' => 'ontology_documentation_role_create',
    'access callback' => 'entity_access',
    'access arguments' => array('create', __documentation_type__, NULL, NULL),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'ontology_documentation.callback.inc',
  );
  $items['admin/'.__documentation_base_url__.'/add/attribute'] = array(
    'title' => 'Add Attribute',
    'description' => 'Allow you to create a new OWL attribute',
    'page callback' => 'ontology_documentation_attribute_create',
    'access callback' => 'entity_access',
    'access arguments' => array('create', __documentation_type__, NULL, NULL),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'ontology_documentation.callback.inc',
  );
  */

  return $items;
}

// Nascondo il titolo dei campi per ogni campo di tipo '__documentation_type__'
function ontology_documentation_preprocess_field(&$variables) {
  if ($variables['element']['#entity_type'] == __documentation_type__) {
    $variables['label_hidden'] = TRUE;
  }
}
// Carica l'entità da visualizzare
function ontology_documentation_load($entity_name, $entity_type, $bundle) {
  // Se almeno un parametro è o non settato o vuoto lancio l'eccezione
  if (!$entity_name || !$entity_type || !$bundle) {
    throw new Exception('ontology_documentation_load(): missing parameters');
  }
  // Sostituisco gli hyphen con gli underscore
  $entity_name = str_replace('-', '_', $entity_name);
  // Creo l'oggetto wrapper per la query
  $entity_query = new EntityFieldQuery();
  // Ricerco l'id del nome del termine
  $entity_query_response = $entity_query->entityCondition('entity_type', $entity_type)
      ->entityCondition('bundle', $bundle)
      ->propertyCondition('title', $entity_name)
      ->execute();
  // Se è presente un'entità con quel nome
  if (!empty($entity_query_response)) {
    // Ne estraggo l'id
    $id = key($entity_query_response[$entity_type]);
    // Carico l'entità
    $entity = entity_load_single($entity_type, $id);
    // Creo il wrapper
    $entity_wrapper = entity_metadata_wrapper(__documentation_type__, $entity);
    // Recupero lo stato
    $is_published = $entity_wrapper->state->value();
    // Se l'entità è non pubblicata ma si posside l'autorizzazione ad amministrarla o
    // pubblicata, carica la pagina con il suo contentuo
    if(!$is_published && user_access('administer ontology_documentation entities') || $is_published) {
      return $entity;
    }
    // Altrimenti ritorno FALSE
    else {
      return FALSE;
    }
  }
  return FALSE;
}
// Carica il bundle da visualizzare
function ontology_documentation_type_load($bundle_type) {
  // Se il tipo di bundle è vuoto o non settato lancio l'eccezione
  if (!$bundle_type) {
    throw new Exception('ontology_documentation_type_load(): missing parameter.');
  }
  // Carico il bundle
  $bundle = entity_load_single('ontology_documentation_type', $bundle_type);
  // Se non è FALSE ritorno il bundle
  if ($bundle) {
    return $bundle;
  }
  // Altrimenti ritorno FALSE
  else {
    return FALSE;
  }
}

function ontology_documentation_permission() {
  $permission = array(
    'administer ontology_documentation entities' => array(
      'title' => t('Administer ontology documentation entities'),
      'description' => t('Allow users to configure ontology documentation entities'),
      'restricted access' => TRUE,
    ),
    'view ontology_documentation entities' => array(
      'title' => t('View ontology documentation entities'),
      'description' => t('Allow users to view ontology documentation entities'),
      'restricted access' => TRUE,
    ),
    'create ontology_documentation entities' => array(
      'title' => t('Create ontology documentation entities'),
      'description' => t('Allow user to create ontology documentation entities'),
      'retricted access' => TRUE,
    ),
    'edit any ontology_documentation entities' => array(
      'title' => t('Edit any ontology documentation entities'),
      'description' => t('Allow users to edit any ontology documentation entities'),
      'restricted access' => TRUE,
    ),
    'edit own ontology_documentation entities' => array(
      'title' => t('Edit own ontology documentation entities'),
      'description' => t('Allow users to edit own ontology documentation entities'),
      'restricted access' => TRUE,
    ),
  );

  return $permission;
}

function ontology_documentation_access($op, $entity, $account, $entity_type) {
  global $user;

  if ($entity_type == __documentation_type_bundle__) {
    $owner = NULL;
  }
  elseif (isset($entity) && $entity_type == __documentation_type__) {
    $owner = $entity->uid;
  }

  if ($op == 'create') {
    return user_access('administer ontology_documentation entities', $user) ||
           user_access('create ontology_documentation entities', $user);
  }
  elseif ($op == 'view') {
    return user_access('administer ontology_documentation entities', $user) ||
           user_access('view ontology_documentation entities', $user);
  }
  elseif ($op == 'update' || $op == 'delete') {
    return user_access('administer ontology_documentation entities', $user)   ||
           user_access('update any ontology_documentation entities', $user)   ||
           user_access('update own ontology_documentation entities', $user)   &&
           $user->uid == $entity_owner && $entity->entityType() == $entity_type;
  }
}

function ontology_documentation_util($item_name, $parameters = NULL) {
  switch ($item_name) {
    case 'get_mastro_uid':
      return OntologyDocumentationUtil::getMastroUid();
      break;
    case 'get_bundles':
      return OntologyDocumentationUtil::getBundles($parameters);
      break;
    case 'config_form':
      return OntologyDocumentationUtil::getConfigForm();
      break;
    case 'entity_edit_form':
      return OntologyDocumentationUtil::getEntityEditForm();
      break;
    case 'entity_revision_form':
      return OntologyDocumentationUtil::getEntityRevisionForm();
      break;
    case 'bundle_edit_form':
      return OntologyDocumentationUtil::getBundleEditForm();
      break;
    case 'mastro_methods_structure':
      return OntologyDocumentationUtil::getMastroMethodsStructure();
      break;
    case 'graphml_viewer_path':
      return OntologyDocumentationUtil::getGraphMLViewerPath();
      break;
    case 'mastro_axiom_types':
      return OntologyDocumentationUtil::getMastroAxiomTypes();
      break;
    case 'obda_types':
      return OntologyDocumentationUtil::getObdaTypes();
      break;
    case 'fields_data_structure':
      return OntologyDocumentationUtil::getFieldsDataStructure();
      break;
  }
}
